#!/usr/bin/env python3

# THIS FILE IS GENERATED BY SCRIPT
# DO NOT MODIFY

import enum
import os
import platform
import sys
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple, Callable, Any, Union, ClassVar

from cffi import FFI

# Define constants
LibName = "unnatural-uwapi"
LibName = "unnatural-uwapi-hard"
UW_VERSION = 36
UW_GameTicksPerSecond = 20

# Define enums
class UwSeverityEnum(enum.IntEnum):
    Note = 0
    Hint = 1
    Warning = 2
    Info = 3
    Error = 4
    Critical = 5

class UwConnectionStateEnum(enum.IntEnum):
    None_ = 0
    Connecting = 1
    Connected = 2
    Error = 3

class UwOrderTypeEnum(enum.IntEnum):
    None_ = 0
    Stop = 1
    Guard = 2
    Run = 3
    Fight = 4
    Load = 5
    Unload = 6
    SelfDestruct = 7

class UwOrderPriorityFlags(enum.IntEnum):
    None_ = 0
    Assistant = 1 << 0
    User = 1 << 1
    Enqueue = 1 << 2
    Repeat = 1 << 3

class UwPriorityEnum(enum.IntEnum):
    Disabled = 0
    Normal = 1
    High = 2

class UwPingEnum(enum.IntEnum):
    None_ = 0
    Attention = 1
    Attack = 2
    Defend = 3
    Rally = 4
    Build = 5
    Evacuate = 6

class UwPathStateEnum(enum.IntEnum):
    None_ = 0
    Searching = 1
    Impossible = 2
    NotFound = 3
    Recompute = 4
    Found = 5
    Finished = 6

class UwForeignPolicyEnum(enum.IntEnum):
    None_ = 0
    Self = 1
    Ally = 2
    Neutral = 3
    Enemy = 4

class UwChatTargetFlags(enum.IntEnum):
    None_ = 0
    Server = 1 << 0
    Direct = 1 << 1
    Self = 1 << 2
    Allies = 1 << 3
    Neutral = 1 << 4
    Enemy = 1 << 5
    Observer = 1 << 6
    Admin = 1 << 7
    Players = Self | Allies | Neutral | Enemy
    Everyone = Players | Observer | Admin

class UwUnitStateFlags(enum.IntEnum):
    None_ = 0
    Shooting = 1 << 0
    Processing = 1 << 1
    Rebuilding = 1 << 2
    Stalling = 1 << 3
    Damaged = 1 << 4

class UwPlayerStateFlags(enum.IntEnum):
    None_ = 0
    Loaded = 1 << 0
    Pause = 1 << 1
    Disconnected = 1 << 2
    Admin = 1 << 3

class UwPlayerConnectionClassEnum(enum.IntEnum):
    None_ = 0
    Computer = 1
    VirtualReality = 2
    Robot = 3
    UwApi = 4

class UwForceStateFlags(enum.IntEnum):
    None_ = 0
    Winner = 1 << 0
    Defeated = 1 << 1
    Disconnected = 1 << 2

class UwGameStateEnum(enum.IntEnum):
    None_ = 0
    Session = 1
    Preparation = 2
    Game = 3
    Finish = 4

class UwTaskTypeEnum(enum.IntEnum):
    None_ = 0
    UnitPathfinding = 1
    ClustersDistances = 2

class UwMapStateEnum(enum.IntEnum):
    None_ = 0
    Downloading = 1
    Loading = 2
    Loaded = 3
    Unloading = 4
    Error = 5

class UwPrototypeTypeEnum(enum.IntEnum):
    None_ = 0
    Resource = 1
    Recipe = 2
    Construction = 3
    Unit = 4
    Upgrade = 5
    Race = 6

class UwOverviewFlags(enum.IntEnum):
    None_ = 0
    Resource = 1 << 0
    Construction = 1 << 1
    MobileUnit = 1 << 2
    StaticUnit = 1 << 3
    Unit = MobileUnit | StaticUnit

# CFFI C definitions
_CDEF = """
// Callback types
typedef void (*UwExceptionCallbackType)(char*);
typedef void (*UwLogCallbackType)(ref* data);
typedef void (*UwConnectionStateCallbackType)(UwConnectionStateEnum state);
typedef void (*UwGameStateCallbackType)(UwGameStateEnum state);
typedef void (*UwUpdateCallbackType)(uint32_t tick, bool);
typedef void (*UwShootingCallbackType)(ref* data);
typedef void (*UwExplosionsCallbackType)(ref* data);
typedef void (*UwForceEliminatedCallbackType)(uint32_t id);
typedef void (*UwChatCallbackType)(char*, uint32_t sender, UwChatTargetFlags flags);
typedef void (*UwTaskCompletedCallbackType)(uint64_t taskUserData, UwTaskTypeEnum type);
typedef void (*UwMapStateCallbackType)(UwMapStateEnum state);

// Struct definitions
struct UwLogCallback {
    public IntPtr;
    public IntPtr;
    public UwSeverityEnum;
};

struct UwMyPlayer {
    public uint;
    public uint;
    public bool;
    public bool;
};

struct UwAssistConfig {
    public bool;
    public bool;
    public bool;
};

struct UwPerformanceStatistics {
    public float;
    public float;
    public float;
    public uint;
    public uint;
};

struct UwOrder {
    public uint;
    public uint;
    public UwOrderTypeEnum;
    public UwOrderPriorityFlags;
};

struct UwOrders {
    public IntPtr;
    public uint;
};

struct UwIds {
    public IntPtr;
    public uint;
};

struct UwProtoComponent {
    public uint;
};

struct UwOwnerComponent {
    public uint;
};

struct UwControllerComponent {
    public uint;
    public uint;
};

struct UwPositionComponent {
    public uint;
    public float;
};

struct UwUnitComponent {
    public UwUnitStateFlags;
    public uint;
};

struct UwLifeComponent {
    public int;
};

struct UwManaComponent {
    public int;
};

struct UwMoveComponent {
    public uint;
    public uint;
    public uint;
    public uint;
    public float;
    public float;
};

struct UwAimComponent {
    public uint;
};

struct UwRecipeComponent {
    public uint;
};

struct UwRecipeStatisticsComponent {
    public uint[][3];
    public uint;
};

struct UwLogisticsTimestampComponent {
    public uint;
};

struct UwPriorityComponent {
    public UwPriorityEnum;
};

struct UwAmountComponent {
    public uint;
};

struct UwAttachmentComponent {
    public uint;
};

struct UwPingComponent {
    public UwPingEnum;
};

struct UwPlayerComponent {
    public char[][28];
    public uint;
    public ulong;
    public uint;
    public float;
    public uint;
    public UwPlayerStateFlags;
    public UwPlayerConnectionClassEnum;
};

struct UwPlayerAiConfigComponent {
    public float;
    public float;
    public float;
    public float;
};

struct UwForceComponent {
    public float[][3];
    public ulong;
    public uint;
    public uint;
    public uint;
    public uint;
    public uint;
    public UwForceStateFlags;
};

struct UwForceDetailsComponent {
    public ulong;
    public ulong;
    public uint;
    public uint;
};

struct UwForeignPolicyComponent {
    public uint[][2];
    public UwForeignPolicyEnum;
};

struct UwDiplomacyProposalComponent {
    public uint;
    public uint;
    public UwForeignPolicyEnum;
};

struct UwShootingUnit {
    public uint;
    public uint;
    public uint;
    public uint;
};

struct UwShootingData {
    public UwShootingUnit;
    public UwShootingUnit;
};

struct UwShootingArray {
    public IntPtr;
    public uint;
};

struct UwExplosionData {
    public uint;
    public uint;
    public uint;
    public uint;
};

struct UwExplosionsArray {
    public IntPtr;
    public uint;
};

struct UwMapInfo {
    public IntPtr;
    public IntPtr;
    public IntPtr;
    public uint;
};

struct UwMapStartingPosition {
    public uint;
    public uint;
    public uint;
};

struct UwMapStartingPositionsArray {
    public IntPtr;
    public uint;
};

struct UwTile {
    public float[][3];
    public float[][3];
    public IntPtr;
    public uint;
    public uint;
    public byte;
    public bool;
};

struct UwCluster {
    public IntPtr;
    public uint;
    public uint;
};

struct UwClustersDistancesQuery {
    public ulong;
    public uint;
    public uint;
    public bool;
};

struct UwClustersDistancesResult {
    public UwIds;
};

struct UwMyForceStatistics {
    public uint;
    public uint;
    public uint;
    public uint;
    public uint;
    public float;
};

struct UwUnitUpgrades {
    public float;
    public float;
    public float;
    public float;
    public float;
    public float;
    public float;
};

struct UwOverviewExtract {
    public IntPtr;
    public uint;
};

struct UwUnitPathfindingQuery {
    public ulong;
    public uint;
    public uint;
    public uint;
    public uint;
    public bool;
};

struct UwUnitPathfindingResult {
    public UwIds;
    public UwPathStateEnum;
};

// Function declarations
uint64_t uwGetLobbyId();
uint64_t uwGetUserId();
uint16_t uwGetServerPort();
void uwAdminSetMapSelection(char* path);
void uwAdminStartGame();
void uwAdminTerminateGame();
void uwAdminSetGameSpeed(float speed);
void uwAdminSetWeatherSpeed(float speed, float offset);
void uwAdminAddAi();
void uwAdminKickPlayer(uint32_t playerId);
void uwAdminPlayerSetAdmin(uint32_t playerId, bool admin);
void uwAdminPlayerSetName(uint32_t playerId, char* name);
void uwAdminPlayerJoinForce(uint32_t playerId, uint32_t forceId);
void uwAdminForceJoinTeam(uint32_t forceId, uint32_t team);
void uwAdminForceSetColor(uint32_t forceId, float r, float g, float b);
void uwAdminForceSetRace(uint32_t forceId, uint32_t raceProto);
void uwAdminSendSuggestedCameraFocus(uint32_t position);
void uwAdminSetAutomaticSuggestedCameraFocus(bool enabled);
void uwAdminSendChat(char* msg, UwChatTargetFlags flags, uint32_t targetId);
void uwAdminSendPing(uint32_t position, UwPingEnum ping, uint32_t targetForce);
void uwInitialize(uint32_t version);
void uwDeinitialize();
void uwSetExceptionCallback(UwExceptionCallbackType callback);
void uwSetLogCallback(UwLogCallbackType callback);
void uwInitializeConsoleLogger();
void uwLog(UwSeverityEnum severity, char* message);
void uwSetConnectionStateCallback(UwConnectionStateCallbackType callback);
UwConnectionStateEnum uwConnectionState();
void uwSetConnectStartGui(bool enabled, char* extraCmdParams);
bool uwConnectFindLan(uint64_t timeoutMicroseconds);
void uwConnectDirect(char* address, uint16_t port);
void uwConnectLobbyId(uint64_t lobbyId);
bool uwConnectEnvironment();
void uwConnectNewServer(uint32_t visibility, char* name, char* extraCmdParams);
bool uwTryReconnect();
void uwDisconnect();
void uwSetPlayerName(char* name);
void uwSetPlayerColor(float r, float g, float b);
void uwSetPlayerRace(uint32_t raceProto);
bool uwMyPlayer(ref* UwMyPlayer);
void uwSetAssistConfig(ref* UwAssistConfig);
void uwPerformanceStatistics(ref* UwPerformanceStatistics);
void uwOrder(uint32_t unit, ref* UwOrder);
void uwOrders(uint32_t unit, ref* UwOrders);
void uwCommandPlaceConstruction(uint32_t constructionProto, uint32_t position, float yaw, uint32_t recipeProto, UwPriorityEnum priority);
void uwCommandSetRecipe(uint32_t unitOrConstructionId, uint32_t recipeProto);
void uwCommandSetPriority(uint32_t unitOrConstructionId, UwPriorityEnum priority);
void uwCommandLoad(uint32_t unitId, uint32_t resourceProto);
void uwCommandUnload(uint32_t unitId);
void uwCommandMove(uint32_t unitId, uint32_t position, float yaw);
void uwCommandAim(uint32_t unitId, uint32_t targetId);
void uwCommandRenounceControl(uint32_t entityId);
void uwCommandSelfDestruct(uint32_t entityId);
void* uwEntityPointer(uint32_t id);
uint32_t uwEntityId(void* entity);
void uwModifiedEntities(ref* UwIds);
void uwAllEntities(ref* UwIds);
bool uwEntityExists(uint32_t id);
bool uwFetchProtoComponent(void* entity, ref* UwProtoComponent);
bool uwFetchOwnerComponent(void* entity, ref* UwOwnerComponent);
bool uwFetchControllerComponent(void* entity, ref* UwControllerComponent);
bool uwFetchPositionComponent(void* entity, ref* UwPositionComponent);
bool uwFetchUnitComponent(void* entity, ref* UwUnitComponent);
bool uwFetchLifeComponent(void* entity, ref* UwLifeComponent);
bool uwFetchManaComponent(void* entity, ref* UwManaComponent);
bool uwFetchMoveComponent(void* entity, ref* UwMoveComponent);
bool uwFetchAimComponent(void* entity, ref* UwAimComponent);
bool uwFetchRecipeComponent(void* entity, ref* UwRecipeComponent);
bool uwFetchRecipeStatisticsComponent(void* entity, ref* UwRecipeStatisticsComponent);
bool uwFetchLogisticsTimestampComponent(void* entity, ref* UwLogisticsTimestampComponent);
bool uwFetchPriorityComponent(void* entity, ref* UwPriorityComponent);
bool uwFetchAmountComponent(void* entity, ref* UwAmountComponent);
bool uwFetchAttachmentComponent(void* entity, ref* UwAttachmentComponent);
bool uwFetchPingComponent(void* entity, ref* UwPingComponent);
bool uwFetchPlayerComponent(void* entity, ref* UwPlayerComponent);
bool uwFetchPlayerAiConfigComponent(void* entity, ref* UwPlayerAiConfigComponent);
bool uwFetchForceComponent(void* entity, ref* UwForceComponent);
bool uwFetchForceDetailsComponent(void* entity, ref* UwForceDetailsComponent);
bool uwFetchForeignPolicyComponent(void* entity, ref* UwForeignPolicyComponent);
bool uwFetchDiplomacyProposalComponent(void* entity, ref* UwDiplomacyProposalComponent);
void uwSetGameStateCallback(UwGameStateCallbackType callback);
UwGameStateEnum uwGameState();
void uwSetUpdateCallback(UwUpdateCallbackType callback);
void uwSetShootingCallback(UwShootingCallbackType callback);
void uwSetExplosionsCallback(UwExplosionsCallbackType callback);
void uwSetForceEliminatedCallback(UwForceEliminatedCallbackType callback);
void uwSetChatCallback(UwChatCallbackType callback);
void uwSetTaskCompletedCallback(UwTaskCompletedCallbackType callback);
void uwSetMapStateCallback(UwMapStateCallbackType callback);
UwMapStateEnum uwMapState();
bool uwMapInfo(ref* UwMapInfo);
void uwMapStartingPositions(ref* UwMapStartingPositionsArray);
uint32_t uwTilesCount();
void uwTile(uint32_t index, ref* UwTile);
uint32_t uwClustersCount();
void uwCluster(uint32_t index, ref* UwCluster);
void uwAreaRange(float x, float y, float z, float radius, ref* UwIds);
void uwAreaConnected(uint32_t position, float radius, ref* UwIds);
void uwAreaNeighborhood(uint32_t position, float radius, ref* UwIds);
void uwAreaExtended(uint32_t position, float radius, ref* UwIds);
bool uwTestVisible(float x1, float y1, float z1, float x2, float y2, float z2);
bool uwTestShooting(uint32_t shooterPosition, uint32_t shooterProto, float shootingRangeUpgrade, uint32_t targetPosition, uint32_t targetProto);
float uwDistanceLine(float x1, float y1, float z1, float x2, float y2, float z2);
float uwDistanceEstimate(uint32_t positionA, uint32_t positionB);
float uwYaw(uint32_t startPosition, uint32_t goalPosition);
void uwStartClustersDistances(ref* UwClustersDistancesQuery);
void uwRetrieveClustersDistances(ref* UwClustersDistancesResult);
void uwAllPrototypes(ref* UwIds);
UwPrototypeTypeEnum uwPrototypeType(uint32_t prototypeId);
void* uwPrototypeJson(uint32_t prototypeId);
void* uwDefinitionsJson();
uint32_t uwHashString(char* str);
void uwMyForceStatistics(ref* UwMyForceStatistics);
UwPathStateEnum uwUnitPathState(uint32_t unitId);
void uwUnitUpgrades(uint32_t unit, ref* UwUnitUpgrades);
bool uwTestShootingEntities(uint32_t shooterId, uint32_t targetId);
bool uwTestConstructionPlacement(uint32_t constructionProto, uint32_t position, uint32_t recipeProto);
uint32_t uwFindConstructionPlacement(uint32_t constructionProto, uint32_t position, uint32_t recipeProto);
UwOverviewFlags uwOverviewFlags(uint32_t position);
void uwOverviewIds(uint32_t position, ref* UwIds);
void uwOverviewExtract(ref* UwOverviewExtract);
void uwStartUnitPathfinding(ref* UwUnitPathfindingQuery);
void uwRetrieveUnitPathfinding(ref* UwUnitPathfindingResult);
"""

class _UwApi:
    """Internal class that loads and provides access to the UW API."""

    def __init__(self, hardened: bool = True):
        self.ffi = FFI()
        self.ffi.cdef(_CDEF)

        # Determine which library to use based on platform
        lib_name = ""
        if platform.system() == "Windows":
            lib_ext = ".dll"
        elif platform.system() == "Darwin":
            lib_ext = ".dylib"
        else:
            lib_ext = ".so"

        # Use hardened library by default
        if hardened:
            # hardened library contains additional checks to verify proper use of the api
            lib_name = "unnatural-uwapi-hard"
        else:
            # non-hard library may crash the program if used incorrectly
            lib_name = "unnatural-uwapi"

        # Prepare library name with extension
        if platform.system() == "Windows":
            full_lib_name = f"{lib_name}{lib_ext}"
        else:
            full_lib_name = f"lib{lib_name}{lib_ext}"

        # Try to find and load the library
        try:
            # First try with full path
            lib_path = self._find_library_path(full_lib_name)
            self.lib = self.ffi.dlopen(lib_path if lib_path else full_lib_name)
        except (OSError, FileNotFoundError) as e:
            # Then try without extension (let the OS find it)
            try:
                self.lib = self.ffi.dlopen(lib_name)
            except OSError as e2:
                if "pytest" in sys.modules or "unittest" in sys.modules:
                    # Create a mock library for testing
                    print(f"Warning: Using mock library because could not load {lib_name}")
                    # Create empty lib using stub functions
                    self.lib = self.ffi.dlopen(None)
                else:
                    raise ImportError(f"Could not load library {lib_name}: {e2}") from e2

        # Initialize the API
        self.lib.uwInitialize(UW_VERSION)

    def _find_library_path(self, lib_name: str) -> Optional[str]:
        """Find the path to the UW API library."""
        # Check environment variable
        uw_root = os.environ.get("UNNATURAL_ROOT")
        if uw_root:
            lib_path = os.path.join(uw_root, lib_name)
            if os.path.exists(lib_path):
                return lib_path

        # Check default Steam installation paths
        if platform.system() == "Windows":
            steam_path = "C:/Program Files (x86)/Steam/steamapps/common/Unnatural Worlds/bin"
        else:
            steam_path = os.path.expanduser("~/.steam/steam/steamapps/common/Unnatural Worlds/bin")

        lib_path = os.path.join(steam_path, lib_name)
        if os.path.exists(lib_path):
            return lib_path

        return None

    def __del__(self):
        """Clean up the API when the object is destroyed."""
        if hasattr(self, "lib"):
            try:
                self.lib.uwDeinitialize()
            except (AttributeError, TypeError):
                # Library might be already unloaded or mock
                pass

def _c_str(s: str) -> "UwApi.ffi.CData":
    """Convert Python string to C string."""
    if s is None:
        return UwApi.ffi.NULL
    return UwApi.ffi.new("char[]", s.encode("utf-8"))

def _to_str(ffi, c_str) -> Optional[str]:
    """Convert C string to Python string."""
    if c_str == ffi.NULL:
        return None
    return ffi.string(c_str).decode("utf-8")

def _unpack_list(ffi, array_struct, field_name: str):
    """Convert a C array struct to a Python list."""
    if not array_struct or not hasattr(array_struct, field_name) or not hasattr(array_struct, "count"):
        return []
    data_ptr = getattr(array_struct, field_name)
    if data_ptr == ffi.NULL or array_struct.count == 0:
        return []
    # Return an array of items that can be indexed
    return [data_ptr[i] for i in range(array_struct.count)]

# Python data classes for C structures
@dataclass
class UwLogCallback:
    IntPtr: public = None
    IntPtr: public = None
    UwSeverityEnum: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.IntPtr = c_struct.IntPtr
        result.IntPtr = c_struct.IntPtr
        result.UwSeverityEnum = c_struct.UwSeverityEnum
        return result

@dataclass
class UwMyPlayer:
    uint: public = None
    uint: public = None
    bool: public = None
    bool: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.bool = c_struct.bool
        result.bool = c_struct.bool
        return result

@dataclass
class UwAssistConfig:
    bool: public = None
    bool: public = None
    bool: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.bool = c_struct.bool
        result.bool = c_struct.bool
        result.bool = c_struct.bool
        return result

@dataclass
class UwPerformanceStatistics:
    float: public = None
    float: public = None
    float: public = None
    uint: public = None
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.float = c_struct.float
        result.float = c_struct.float
        result.float = c_struct.float
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        return result

@dataclass
class UwOrder:
    uint: public = None
    uint: public = None
    UwOrderTypeEnum: public = None
    UwOrderPriorityFlags: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.UwOrderTypeEnum = c_struct.UwOrderTypeEnum
        result.UwOrderPriorityFlags = c_struct.UwOrderPriorityFlags
        return result

@dataclass
class UwOrders:
    IntPtr: public = None
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.IntPtr = c_struct.IntPtr
        result.uint = c_struct.uint
        return result

@dataclass
class UwIds:
    IntPtr: public = None
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.IntPtr = c_struct.IntPtr
        result.uint = c_struct.uint
        return result

@dataclass
class UwProtoComponent:
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint = c_struct.uint
        return result

@dataclass
class UwOwnerComponent:
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint = c_struct.uint
        return result

@dataclass
class UwControllerComponent:
    uint: public = None
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        return result

@dataclass
class UwPositionComponent:
    uint: public = None
    float: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint = c_struct.uint
        result.float = c_struct.float
        return result

@dataclass
class UwUnitComponent:
    UwUnitStateFlags: public = None
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.UwUnitStateFlags = c_struct.UwUnitStateFlags
        result.uint = c_struct.uint
        return result

@dataclass
class UwLifeComponent:
    int: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.int = c_struct.int
        return result

@dataclass
class UwManaComponent:
    int: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.int = c_struct.int
        return result

@dataclass
class UwMoveComponent:
    uint: public = None
    uint: public = None
    uint: public = None
    uint: public = None
    float: public = None
    float: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.float = c_struct.float
        result.float = c_struct.float
        return result

@dataclass
class UwAimComponent:
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint = c_struct.uint
        return result

@dataclass
class UwRecipeComponent:
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint = c_struct.uint
        return result

@dataclass
class UwRecipeStatisticsComponent:
    uint[]: public = field(default_factory=lambda: [0] * 3)
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint[] = [c_struct.uint[][i] for i in range(3)]
        result.uint = c_struct.uint
        return result

@dataclass
class UwLogisticsTimestampComponent:
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint = c_struct.uint
        return result

@dataclass
class UwPriorityComponent:
    UwPriorityEnum: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.UwPriorityEnum = c_struct.UwPriorityEnum
        return result

@dataclass
class UwAmountComponent:
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint = c_struct.uint
        return result

@dataclass
class UwAttachmentComponent:
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint = c_struct.uint
        return result

@dataclass
class UwPingComponent:
    UwPingEnum: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.UwPingEnum = c_struct.UwPingEnum
        return result

@dataclass
class UwPlayerComponent:
    char[]: public = field(default_factory=lambda: [0] * 28)
    uint: public = None
    ulong: public = None
    uint: public = None
    float: public = None
    uint: public = None
    UwPlayerStateFlags: public = None
    UwPlayerConnectionClassEnum: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.char[] = [c_struct.char[][i] for i in range(28)]
        result.uint = c_struct.uint
        result.ulong = c_struct.ulong
        result.uint = c_struct.uint
        result.float = c_struct.float
        result.uint = c_struct.uint
        result.UwPlayerStateFlags = c_struct.UwPlayerStateFlags
        result.UwPlayerConnectionClassEnum = c_struct.UwPlayerConnectionClassEnum
        return result

@dataclass
class UwPlayerAiConfigComponent:
    float: public = None
    float: public = None
    float: public = None
    float: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.float = c_struct.float
        result.float = c_struct.float
        result.float = c_struct.float
        result.float = c_struct.float
        return result

@dataclass
class UwForceComponent:
    float[]: public = field(default_factory=lambda: [0] * 3)
    ulong: public = None
    uint: public = None
    uint: public = None
    uint: public = None
    uint: public = None
    uint: public = None
    UwForceStateFlags: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.float[] = [c_struct.float[][i] for i in range(3)]
        result.ulong = c_struct.ulong
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.UwForceStateFlags = c_struct.UwForceStateFlags
        return result

@dataclass
class UwForceDetailsComponent:
    ulong: public = None
    ulong: public = None
    uint: public = None
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.ulong = c_struct.ulong
        result.ulong = c_struct.ulong
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        return result

@dataclass
class UwForeignPolicyComponent:
    uint[]: public = field(default_factory=lambda: [0] * 2)
    UwForeignPolicyEnum: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint[] = [c_struct.uint[][i] for i in range(2)]
        result.UwForeignPolicyEnum = c_struct.UwForeignPolicyEnum
        return result

@dataclass
class UwDiplomacyProposalComponent:
    uint: public = None
    uint: public = None
    UwForeignPolicyEnum: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.UwForeignPolicyEnum = c_struct.UwForeignPolicyEnum
        return result

@dataclass
class UwShootingUnit:
    uint: public = None
    uint: public = None
    uint: public = None
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        return result

@dataclass
class UwShootingData:
    UwShootingUnit: public = None
    UwShootingUnit: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.UwShootingUnit = c_struct.UwShootingUnit
        result.UwShootingUnit = c_struct.UwShootingUnit
        return result

@dataclass
class UwShootingArray:
    IntPtr: public = None
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.IntPtr = c_struct.IntPtr
        result.uint = c_struct.uint
        return result

@dataclass
class UwExplosionData:
    uint: public = None
    uint: public = None
    uint: public = None
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        return result

@dataclass
class UwExplosionsArray:
    IntPtr: public = None
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.IntPtr = c_struct.IntPtr
        result.uint = c_struct.uint
        return result

@dataclass
class UwMapInfo:
    IntPtr: public = None
    IntPtr: public = None
    IntPtr: public = None
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.IntPtr = c_struct.IntPtr
        result.IntPtr = c_struct.IntPtr
        result.IntPtr = c_struct.IntPtr
        result.uint = c_struct.uint
        return result

@dataclass
class UwMapStartingPosition:
    uint: public = None
    uint: public = None
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        return result

@dataclass
class UwMapStartingPositionsArray:
    IntPtr: public = None
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.IntPtr = c_struct.IntPtr
        result.uint = c_struct.uint
        return result

@dataclass
class UwTile:
    float[]: public = field(default_factory=lambda: [0] * 3)
    float[]: public = field(default_factory=lambda: [0] * 3)
    IntPtr: public = None
    uint: public = None
    uint: public = None
    byte: public = None
    bool: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.float[] = [c_struct.float[][i] for i in range(3)]
        result.float[] = [c_struct.float[][i] for i in range(3)]
        result.IntPtr = c_struct.IntPtr
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.byte = c_struct.byte
        result.bool = c_struct.bool
        return result

@dataclass
class UwCluster:
    IntPtr: public = None
    uint: public = None
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.IntPtr = c_struct.IntPtr
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        return result

@dataclass
class UwClustersDistancesQuery:
    ulong: public = None
    uint: public = None
    uint: public = None
    bool: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.ulong = c_struct.ulong
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.bool = c_struct.bool
        return result

@dataclass
class UwClustersDistancesResult:
    UwIds: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.UwIds = c_struct.UwIds
        return result

@dataclass
class UwMyForceStatistics:
    uint: public = None
    uint: public = None
    uint: public = None
    uint: public = None
    uint: public = None
    float: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.float = c_struct.float
        return result

@dataclass
class UwUnitUpgrades:
    float: public = None
    float: public = None
    float: public = None
    float: public = None
    float: public = None
    float: public = None
    float: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.float = c_struct.float
        result.float = c_struct.float
        result.float = c_struct.float
        result.float = c_struct.float
        result.float = c_struct.float
        result.float = c_struct.float
        result.float = c_struct.float
        return result

@dataclass
class UwOverviewExtract:
    IntPtr: public = None
    uint: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.IntPtr = c_struct.IntPtr
        result.uint = c_struct.uint
        return result

@dataclass
class UwUnitPathfindingQuery:
    ulong: public = None
    uint: public = None
    uint: public = None
    uint: public = None
    uint: public = None
    bool: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.ulong = c_struct.ulong
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.uint = c_struct.uint
        result.bool = c_struct.bool
        return result

@dataclass
class UwUnitPathfindingResult:
    UwIds: public = None
    UwPathStateEnum: public = None

    @classmethod
    def from_c(cls, ffi, c_struct):
        """Create a Python object from a C struct."""
        if c_struct == ffi.NULL:
            return None
        result = cls()
        result.UwIds = c_struct.UwIds
        result.UwPathStateEnum = c_struct.UwPathStateEnum
        return result

class Entity:
    """Represents an entity in the game with component-based access."""
    def __init__(self, id: int):
        """Initialize an entity with its ID."""
        self.Id = id
        self._components = {}
        self._pointer = UwApi.lib.uwEntityPointer(id)

    def has(self, component_name: str) -> bool:
        """Check if entity has a specific component."""
        return hasattr(self, component_name)

    def own(self) -> bool:
        """Check if this entity is owned by the player."""
        if not hasattr(self, "Owner"):
            self.fetch_owner()
        return hasattr(self, "Owner") and self.Owner.force == UwApi.my_force

    def policy(self) -> "ForeignPolicyEnum":
        """Get the policy status of this entity (ally, enemy, etc.)."""
        if not hasattr(self, "Owner"):
            self.fetch_owner()
        if not hasattr(self, "Owner"):
            return ForeignPolicyEnum.None_
        if self.Owner.force == UwApi.my_force:
            return ForeignPolicyEnum.Self
        return UwApi._get_force_policy(self.Owner.force)

    def fetch_proto(self) -> bool:
        """Fetch the Proto component for this entity."""
        c_component = UwApi.ffi.new("struct UwProtoComponent *")
        if UwApi.lib.uwFetchUwProtoComponent(self._pointer, c_component):
            self.Proto = UwProtoComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_owner(self) -> bool:
        """Fetch the Owner component for this entity."""
        c_component = UwApi.ffi.new("struct UwOwnerComponent *")
        if UwApi.lib.uwFetchUwOwnerComponent(self._pointer, c_component):
            self.Owner = UwOwnerComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_controller(self) -> bool:
        """Fetch the Controller component for this entity."""
        c_component = UwApi.ffi.new("struct UwControllerComponent *")
        if UwApi.lib.uwFetchUwControllerComponent(self._pointer, c_component):
            self.Controller = UwControllerComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_position(self) -> bool:
        """Fetch the Position component for this entity."""
        c_component = UwApi.ffi.new("struct UwPositionComponent *")
        if UwApi.lib.uwFetchUwPositionComponent(self._pointer, c_component):
            self.Position = UwPositionComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_unit(self) -> bool:
        """Fetch the Unit component for this entity."""
        c_component = UwApi.ffi.new("struct UwUnitComponent *")
        if UwApi.lib.uwFetchUwUnitComponent(self._pointer, c_component):
            self.Unit = UwUnitComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_life(self) -> bool:
        """Fetch the Life component for this entity."""
        c_component = UwApi.ffi.new("struct UwLifeComponent *")
        if UwApi.lib.uwFetchUwLifeComponent(self._pointer, c_component):
            self.Life = UwLifeComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_mana(self) -> bool:
        """Fetch the Mana component for this entity."""
        c_component = UwApi.ffi.new("struct UwManaComponent *")
        if UwApi.lib.uwFetchUwManaComponent(self._pointer, c_component):
            self.Mana = UwManaComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_move(self) -> bool:
        """Fetch the Move component for this entity."""
        c_component = UwApi.ffi.new("struct UwMoveComponent *")
        if UwApi.lib.uwFetchUwMoveComponent(self._pointer, c_component):
            self.Move = UwMoveComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_aim(self) -> bool:
        """Fetch the Aim component for this entity."""
        c_component = UwApi.ffi.new("struct UwAimComponent *")
        if UwApi.lib.uwFetchUwAimComponent(self._pointer, c_component):
            self.Aim = UwAimComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_recipe(self) -> bool:
        """Fetch the Recipe component for this entity."""
        c_component = UwApi.ffi.new("struct UwRecipeComponent *")
        if UwApi.lib.uwFetchUwRecipeComponent(self._pointer, c_component):
            self.Recipe = UwRecipeComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_recipestatistics(self) -> bool:
        """Fetch the RecipeStatistics component for this entity."""
        c_component = UwApi.ffi.new("struct UwRecipeStatisticsComponent *")
        if UwApi.lib.uwFetchUwRecipeStatisticsComponent(self._pointer, c_component):
            self.RecipeStatistics = UwRecipeStatisticsComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_logisticstimestamp(self) -> bool:
        """Fetch the LogisticsTimestamp component for this entity."""
        c_component = UwApi.ffi.new("struct UwLogisticsTimestampComponent *")
        if UwApi.lib.uwFetchUwLogisticsTimestampComponent(self._pointer, c_component):
            self.LogisticsTimestamp = UwLogisticsTimestampComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_priority(self) -> bool:
        """Fetch the Priority component for this entity."""
        c_component = UwApi.ffi.new("struct UwPriorityComponent *")
        if UwApi.lib.uwFetchUwPriorityComponent(self._pointer, c_component):
            self.Priority = UwPriorityComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_amount(self) -> bool:
        """Fetch the Amount component for this entity."""
        c_component = UwApi.ffi.new("struct UwAmountComponent *")
        if UwApi.lib.uwFetchUwAmountComponent(self._pointer, c_component):
            self.Amount = UwAmountComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_attachment(self) -> bool:
        """Fetch the Attachment component for this entity."""
        c_component = UwApi.ffi.new("struct UwAttachmentComponent *")
        if UwApi.lib.uwFetchUwAttachmentComponent(self._pointer, c_component):
            self.Attachment = UwAttachmentComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_ping(self) -> bool:
        """Fetch the Ping component for this entity."""
        c_component = UwApi.ffi.new("struct UwPingComponent *")
        if UwApi.lib.uwFetchUwPingComponent(self._pointer, c_component):
            self.Ping = UwPingComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_player(self) -> bool:
        """Fetch the Player component for this entity."""
        c_component = UwApi.ffi.new("struct UwPlayerComponent *")
        if UwApi.lib.uwFetchUwPlayerComponent(self._pointer, c_component):
            self.Player = UwPlayerComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_playeraiconfig(self) -> bool:
        """Fetch the PlayerAiConfig component for this entity."""
        c_component = UwApi.ffi.new("struct UwPlayerAiConfigComponent *")
        if UwApi.lib.uwFetchUwPlayerAiConfigComponent(self._pointer, c_component):
            self.PlayerAiConfig = UwPlayerAiConfigComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_force(self) -> bool:
        """Fetch the Force component for this entity."""
        c_component = UwApi.ffi.new("struct UwForceComponent *")
        if UwApi.lib.uwFetchUwForceComponent(self._pointer, c_component):
            self.Force = UwForceComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_forcedetails(self) -> bool:
        """Fetch the ForceDetails component for this entity."""
        c_component = UwApi.ffi.new("struct UwForceDetailsComponent *")
        if UwApi.lib.uwFetchUwForceDetailsComponent(self._pointer, c_component):
            self.ForceDetails = UwForceDetailsComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_foreignpolicy(self) -> bool:
        """Fetch the ForeignPolicy component for this entity."""
        c_component = UwApi.ffi.new("struct UwForeignPolicyComponent *")
        if UwApi.lib.uwFetchUwForeignPolicyComponent(self._pointer, c_component):
            self.ForeignPolicy = UwForeignPolicyComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def fetch_diplomacyproposal(self) -> bool:
        """Fetch the DiplomacyProposal component for this entity."""
        c_component = UwApi.ffi.new("struct UwDiplomacyProposalComponent *")
        if UwApi.lib.uwFetchUwDiplomacyProposalComponent(self._pointer, c_component):
            self.DiplomacyProposal = UwDiplomacyProposalComponent.from_c(UwApi.ffi, c_component)
            return True
        return False

    def update(self) -> "Entity":
        """Update all components of this entity."""
        self.fetch_proto()
        self.fetch_owner()
        self.fetch_controller()
        self.fetch_position()
        self.fetch_unit()
        self.fetch_life()
        self.fetch_mana()
        self.fetch_move()
        self.fetch_aim()
        self.fetch_recipe()
        self.fetch_recipestatistics()
        self.fetch_logisticstimestamp()
        self.fetch_priority()
        self.fetch_amount()
        self.fetch_attachment()
        self.fetch_ping()
        self.fetch_player()
        self.fetch_playeraiconfig()
        self.fetch_force()
        self.fetch_forcedetails()
        self.fetch_foreignpolicy()
        self.fetch_diplomacyproposal()
        return self

# Main API class
class UwApi:
    """Main interface to the UW API."""
    # Class variables for CFFI instance and loaded library
    _api_instance = None
    ffi = None
    lib = None
    my_force = 0  # Will be set once connected

    @classmethod
    def initialize(cls, hardened: bool = True):
        """Initialize the UW API."""
        if cls._api_instance is None:
            cls._api_instance = _UwApi(hardened)
            cls.ffi = cls._api_instance.ffi
            cls.lib = cls._api_instance.lib
        return cls

    @classmethod
    def shutdown(cls):
        """Shut down the UW API."""
        if cls._api_instance:
            cls.lib.uwDeinitialize()
            cls._api_instance = None
            cls.ffi = None
            cls.lib = None

    @classmethod
    def _get_force_policy(cls, force_id: int) -> ForeignPolicyEnum:
        """Get the foreign policy for a force."""
        # This would need to query game state
        # For now, return a default
        return ForeignPolicyEnum.Neutral

    # API function wrappers
    @classmethod
    def get_lobby_id(cls, ) -> int:
        """Wrapper for uwGetLobbyId."""
        return cls.lib.uwGetLobbyId()

    @classmethod
    def get_user_id(cls, ) -> int:
        """Wrapper for uwGetUserId."""
        return cls.lib.uwGetUserId()

    @classmethod
    def get_server_port(cls, ) -> ushort:
        """Wrapper for uwGetServerPort."""
        return cls.lib.uwGetServerPort()

    @classmethod
    def admin_set_map_selection(cls, path: str) -> None:
        """Wrapper for uwAdminSetMapSelection."""
        result = cls.lib.uwAdminSetMapSelection(_c_str(path))
        return None

    @classmethod
    def admin_start_game(cls, ) -> None:
        """Wrapper for uwAdminStartGame."""
        return cls.lib.uwAdminStartGame()

    @classmethod
    def admin_terminate_game(cls, ) -> None:
        """Wrapper for uwAdminTerminateGame."""
        return cls.lib.uwAdminTerminateGame()

    @classmethod
    def admin_set_game_speed(cls, speed: float) -> None:
        """Wrapper for uwAdminSetGameSpeed."""
        result = cls.lib.uwAdminSetGameSpeed(speed)
        return None

    @classmethod
    def admin_set_weather_speed(cls, speed: float, offset: float) -> None:
        """Wrapper for uwAdminSetWeatherSpeed."""
        result = cls.lib.uwAdminSetWeatherSpeed(speed, offset)
        return None

    @classmethod
    def admin_add_ai(cls, ) -> None:
        """Wrapper for uwAdminAddAi."""
        return cls.lib.uwAdminAddAi()

    @classmethod
    def admin_kick_player(cls, playerId: int) -> None:
        """Wrapper for uwAdminKickPlayer."""
        result = cls.lib.uwAdminKickPlayer(playerId)
        return None

    @classmethod
    def admin_player_set_admin(cls, playerId: int, admin: bool) -> None:
        """Wrapper for uwAdminPlayerSetAdmin."""
        result = cls.lib.uwAdminPlayerSetAdmin(playerId, admin)
        return None

    @classmethod
    def admin_player_set_name(cls, playerId: int, name: str) -> None:
        """Wrapper for uwAdminPlayerSetName."""
        result = cls.lib.uwAdminPlayerSetName(playerId, _c_str(name))
        return None

    @classmethod
    def admin_player_join_force(cls, playerId: int, forceId: int) -> None:
        """Wrapper for uwAdminPlayerJoinForce."""
        result = cls.lib.uwAdminPlayerJoinForce(playerId, forceId)
        return None

    @classmethod
    def admin_force_join_team(cls, forceId: int, team: int) -> None:
        """Wrapper for uwAdminForceJoinTeam."""
        result = cls.lib.uwAdminForceJoinTeam(forceId, team)
        return None

    @classmethod
    def admin_force_set_color(cls, forceId: int, r: float, g: float, b: float) -> None:
        """Wrapper for uwAdminForceSetColor."""
        result = cls.lib.uwAdminForceSetColor(forceId, r, g, b)
        return None

    @classmethod
    def admin_force_set_race(cls, forceId: int, raceProto: int) -> None:
        """Wrapper for uwAdminForceSetRace."""
        result = cls.lib.uwAdminForceSetRace(forceId, raceProto)
        return None

    @classmethod
    def admin_send_suggested_camera_focus(cls, position: int) -> None:
        """Wrapper for uwAdminSendSuggestedCameraFocus."""
        result = cls.lib.uwAdminSendSuggestedCameraFocus(position)
        return None

    @classmethod
    def admin_set_automatic_suggested_camera_focus(cls, enabled: bool) -> None:
        """Wrapper for uwAdminSetAutomaticSuggestedCameraFocus."""
        result = cls.lib.uwAdminSetAutomaticSuggestedCameraFocus(enabled)
        return None

    @classmethod
    def admin_send_chat(cls, msg: str, flags: UwChatTargetFlags, targetId: int) -> None:
        """Wrapper for uwAdminSendChat."""
        result = cls.lib.uwAdminSendChat(_c_str(msg), flags, targetId)
        return None

    @classmethod
    def admin_send_ping(cls, position: int, ping: UwPingEnum, targetForce: int) -> None:
        """Wrapper for uwAdminSendPing."""
        result = cls.lib.uwAdminSendPing(position, ping, targetForce)
        return None

    @classmethod
    def initialize(cls, version: int) -> None:
        """Wrapper for uwInitialize."""
        result = cls.lib.uwInitialize(version)
        return None

    @classmethod
    def deinitialize(cls, ) -> None:
        """Wrapper for uwDeinitialize."""
        return cls.lib.uwDeinitialize()

    @classmethod
    def set_exception_callback(cls, ) -> None:
        """Wrapper for uwSetExceptionCallback."""
        result = cls.lib.uwSetExceptionCallback()
        return None

    @classmethod
    def set_log_callback(cls, ) -> None:
        """Wrapper for uwSetLogCallback."""
        result = cls.lib.uwSetLogCallback()
        return None

    @classmethod
    def initialize_console_logger(cls, ) -> None:
        """Wrapper for uwInitializeConsoleLogger."""
        return cls.lib.uwInitializeConsoleLogger()

    @classmethod
    def log(cls, severity: UwSeverityEnum, message: str) -> None:
        """Wrapper for uwLog."""
        result = cls.lib.uwLog(severity, _c_str(message))
        return None

    @classmethod
    def set_connection_state_callback(cls, ) -> None:
        """Wrapper for uwSetConnectionStateCallback."""
        result = cls.lib.uwSetConnectionStateCallback()
        return None

    @classmethod
    def connection_state(cls, ) -> UwConnectionStateEnum:
        """Wrapper for uwConnectionState."""
        return cls.lib.uwConnectionState()

    @classmethod
    def set_connect_start_gui(cls, enabled: bool, extraCmdParams: str) -> None:
        """Wrapper for uwSetConnectStartGui."""
        result = cls.lib.uwSetConnectStartGui(enabled, _c_str(extraCmdParams))
        return None

    @classmethod
    def connect_find_lan(cls, timeoutMicroseconds: ulong) -> bool:
        """Wrapper for uwConnectFindLan."""
        result = cls.lib.uwConnectFindLan(timeoutMicroseconds)
        return result

    @classmethod
    def connect_direct(cls, address: str, port: ushort) -> None:
        """Wrapper for uwConnectDirect."""
        result = cls.lib.uwConnectDirect(_c_str(address), port)
        return None

    @classmethod
    def connect_lobby_id(cls, lobbyId: ulong) -> None:
        """Wrapper for uwConnectLobbyId."""
        result = cls.lib.uwConnectLobbyId(lobbyId)
        return None

    @classmethod
    def connect_environment(cls, ) -> bool:
        """Wrapper for uwConnectEnvironment."""
        return cls.lib.uwConnectEnvironment()

    @classmethod
    def connect_new_server(cls, visibility: int, name: str, extraCmdParams: str) -> None:
        """Wrapper for uwConnectNewServer."""
        result = cls.lib.uwConnectNewServer(visibility, _c_str(name), _c_str(extraCmdParams))
        return None

    @classmethod
    def try_reconnect(cls, ) -> bool:
        """Wrapper for uwTryReconnect."""
        return cls.lib.uwTryReconnect()

    @classmethod
    def disconnect(cls, ) -> None:
        """Wrapper for uwDisconnect."""
        return cls.lib.uwDisconnect()

    @classmethod
    def set_player_name(cls, name: str) -> None:
        """Wrapper for uwSetPlayerName."""
        result = cls.lib.uwSetPlayerName(_c_str(name))
        return None

    @classmethod
    def set_player_color(cls, r: float, g: float, b: float) -> None:
        """Wrapper for uwSetPlayerColor."""
        result = cls.lib.uwSetPlayerColor(r, g, b)
        return None

    @classmethod
    def set_player_race(cls, raceProto: int) -> None:
        """Wrapper for uwSetPlayerRace."""
        result = cls.lib.uwSetPlayerRace(raceProto)
        return None

    @classmethod
    def my_player(cls, UwMyPlayer: Optional[ref]) -> bool:
        """Wrapper for uwMyPlayer."""
        c_UwMyPlayer = cls.ffi.new("struct ref *")
        result = cls.lib.uwMyPlayer(c_UwMyPlayer)
        return result

    @classmethod
    def set_assist_config(cls, UwAssistConfig: Optional[ref]) -> None:
        """Wrapper for uwSetAssistConfig."""
        c_UwAssistConfig = cls.ffi.new("struct ref *")
        result = cls.lib.uwSetAssistConfig(c_UwAssistConfig)
        return ref.from_c(cls.ffi, c_UwAssistConfig)

    @classmethod
    def performance_statistics(cls, UwPerformanceStatistics: Optional[ref]) -> None:
        """Wrapper for uwPerformanceStatistics."""
        c_UwPerformanceStatistics = cls.ffi.new("struct ref *")
        result = cls.lib.uwPerformanceStatistics(c_UwPerformanceStatistics)
        return ref.from_c(cls.ffi, c_UwPerformanceStatistics)

    @classmethod
    def order(cls, unit: int, UwOrder: Optional[ref]) -> None:
        """Wrapper for uwOrder."""
        c_UwOrder = cls.ffi.new("struct ref *")
        result = cls.lib.uwOrder(unit, c_UwOrder)
        return ref.from_c(cls.ffi, c_UwOrder)

    @classmethod
    def orders(cls, unit: int, UwOrders: Optional[ref]) -> None:
        """Wrapper for uwOrders."""
        c_UwOrders = cls.ffi.new("struct ref *")
        result = cls.lib.uwOrders(unit, c_UwOrders)
        return ref.from_c(cls.ffi, c_UwOrders)

    @classmethod
    def command_place_construction(cls, constructionProto: int, position: int, yaw: float, recipeProto: int, priority: UwPriorityEnum) -> None:
        """Wrapper for uwCommandPlaceConstruction."""
        result = cls.lib.uwCommandPlaceConstruction(constructionProto, position, yaw, recipeProto, priority)
        return None

    @classmethod
    def command_set_recipe(cls, unitOrConstructionId: int, recipeProto: int) -> None:
        """Wrapper for uwCommandSetRecipe."""
        result = cls.lib.uwCommandSetRecipe(unitOrConstructionId, recipeProto)
        return None

    @classmethod
    def command_set_priority(cls, unitOrConstructionId: int, priority: UwPriorityEnum) -> None:
        """Wrapper for uwCommandSetPriority."""
        result = cls.lib.uwCommandSetPriority(unitOrConstructionId, priority)
        return None

    @classmethod
    def command_load(cls, unitId: int, resourceProto: int) -> None:
        """Wrapper for uwCommandLoad."""
        result = cls.lib.uwCommandLoad(unitId, resourceProto)
        return None

    @classmethod
    def command_unload(cls, unitId: int) -> None:
        """Wrapper for uwCommandUnload."""
        result = cls.lib.uwCommandUnload(unitId)
        return None

    @classmethod
    def command_move(cls, unitId: int, position: int, yaw: float) -> None:
        """Wrapper for uwCommandMove."""
        result = cls.lib.uwCommandMove(unitId, position, yaw)
        return None

    @classmethod
    def command_aim(cls, unitId: int, targetId: int) -> None:
        """Wrapper for uwCommandAim."""
        result = cls.lib.uwCommandAim(unitId, targetId)
        return None

    @classmethod
    def command_renounce_control(cls, entityId: int) -> None:
        """Wrapper for uwCommandRenounceControl."""
        result = cls.lib.uwCommandRenounceControl(entityId)
        return None

    @classmethod
    def command_self_destruct(cls, entityId: int) -> None:
        """Wrapper for uwCommandSelfDestruct."""
        result = cls.lib.uwCommandSelfDestruct(entityId)
        return None

    @classmethod
    def entity_pointer(cls, id: int) -> IntPtr:
        """Wrapper for uwEntityPointer."""
        result = cls.lib.uwEntityPointer(id)
        return result

    @classmethod
    def entity_id(cls, entity: IntPtr) -> int:
        """Wrapper for uwEntityId."""
        result = cls.lib.uwEntityId(entity)
        return result

    @classmethod
    def modified_entities(cls, UwIds: Optional[ref]) -> None:
        """Wrapper for uwModifiedEntities."""
        c_UwIds = cls.ffi.new("struct ref *")
        result = cls.lib.uwModifiedEntities(c_UwIds)
        return ref.from_c(cls.ffi, c_UwIds)

    @classmethod
    def all_entities(cls, UwIds: Optional[ref]) -> None:
        """Wrapper for uwAllEntities."""
        c_UwIds = cls.ffi.new("struct ref *")
        result = cls.lib.uwAllEntities(c_UwIds)
        return ref.from_c(cls.ffi, c_UwIds)

    @classmethod
    def entity_exists(cls, id: int) -> bool:
        """Wrapper for uwEntityExists."""
        result = cls.lib.uwEntityExists(id)
        return result

    @classmethod
    def fetch_proto_component(cls, entity: IntPtr, UwProtoComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchProtoComponent."""
        c_UwProtoComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchProtoComponent(entity, c_UwProtoComponent)
        return result

    @classmethod
    def fetch_owner_component(cls, entity: IntPtr, UwOwnerComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchOwnerComponent."""
        c_UwOwnerComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchOwnerComponent(entity, c_UwOwnerComponent)
        return result

    @classmethod
    def fetch_controller_component(cls, entity: IntPtr, UwControllerComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchControllerComponent."""
        c_UwControllerComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchControllerComponent(entity, c_UwControllerComponent)
        return result

    @classmethod
    def fetch_position_component(cls, entity: IntPtr, UwPositionComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchPositionComponent."""
        c_UwPositionComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchPositionComponent(entity, c_UwPositionComponent)
        return result

    @classmethod
    def fetch_unit_component(cls, entity: IntPtr, UwUnitComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchUnitComponent."""
        c_UwUnitComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchUnitComponent(entity, c_UwUnitComponent)
        return result

    @classmethod
    def fetch_life_component(cls, entity: IntPtr, UwLifeComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchLifeComponent."""
        c_UwLifeComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchLifeComponent(entity, c_UwLifeComponent)
        return result

    @classmethod
    def fetch_mana_component(cls, entity: IntPtr, UwManaComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchManaComponent."""
        c_UwManaComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchManaComponent(entity, c_UwManaComponent)
        return result

    @classmethod
    def fetch_move_component(cls, entity: IntPtr, UwMoveComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchMoveComponent."""
        c_UwMoveComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchMoveComponent(entity, c_UwMoveComponent)
        return result

    @classmethod
    def fetch_aim_component(cls, entity: IntPtr, UwAimComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchAimComponent."""
        c_UwAimComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchAimComponent(entity, c_UwAimComponent)
        return result

    @classmethod
    def fetch_recipe_component(cls, entity: IntPtr, UwRecipeComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchRecipeComponent."""
        c_UwRecipeComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchRecipeComponent(entity, c_UwRecipeComponent)
        return result

    @classmethod
    def fetch_recipe_statistics_component(cls, entity: IntPtr, UwRecipeStatisticsComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchRecipeStatisticsComponent."""
        c_UwRecipeStatisticsComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchRecipeStatisticsComponent(entity, c_UwRecipeStatisticsComponent)
        return result

    @classmethod
    def fetch_logistics_timestamp_component(cls, entity: IntPtr, UwLogisticsTimestampComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchLogisticsTimestampComponent."""
        c_UwLogisticsTimestampComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchLogisticsTimestampComponent(entity, c_UwLogisticsTimestampComponent)
        return result

    @classmethod
    def fetch_priority_component(cls, entity: IntPtr, UwPriorityComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchPriorityComponent."""
        c_UwPriorityComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchPriorityComponent(entity, c_UwPriorityComponent)
        return result

    @classmethod
    def fetch_amount_component(cls, entity: IntPtr, UwAmountComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchAmountComponent."""
        c_UwAmountComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchAmountComponent(entity, c_UwAmountComponent)
        return result

    @classmethod
    def fetch_attachment_component(cls, entity: IntPtr, UwAttachmentComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchAttachmentComponent."""
        c_UwAttachmentComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchAttachmentComponent(entity, c_UwAttachmentComponent)
        return result

    @classmethod
    def fetch_ping_component(cls, entity: IntPtr, UwPingComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchPingComponent."""
        c_UwPingComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchPingComponent(entity, c_UwPingComponent)
        return result

    @classmethod
    def fetch_player_component(cls, entity: IntPtr, UwPlayerComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchPlayerComponent."""
        c_UwPlayerComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchPlayerComponent(entity, c_UwPlayerComponent)
        return result

    @classmethod
    def fetch_player_ai_config_component(cls, entity: IntPtr, UwPlayerAiConfigComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchPlayerAiConfigComponent."""
        c_UwPlayerAiConfigComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchPlayerAiConfigComponent(entity, c_UwPlayerAiConfigComponent)
        return result

    @classmethod
    def fetch_force_component(cls, entity: IntPtr, UwForceComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchForceComponent."""
        c_UwForceComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchForceComponent(entity, c_UwForceComponent)
        return result

    @classmethod
    def fetch_force_details_component(cls, entity: IntPtr, UwForceDetailsComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchForceDetailsComponent."""
        c_UwForceDetailsComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchForceDetailsComponent(entity, c_UwForceDetailsComponent)
        return result

    @classmethod
    def fetch_foreign_policy_component(cls, entity: IntPtr, UwForeignPolicyComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchForeignPolicyComponent."""
        c_UwForeignPolicyComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchForeignPolicyComponent(entity, c_UwForeignPolicyComponent)
        return result

    @classmethod
    def fetch_diplomacy_proposal_component(cls, entity: IntPtr, UwDiplomacyProposalComponent: Optional[ref]) -> bool:
        """Wrapper for uwFetchDiplomacyProposalComponent."""
        c_UwDiplomacyProposalComponent = cls.ffi.new("struct ref *")
        result = cls.lib.uwFetchDiplomacyProposalComponent(entity, c_UwDiplomacyProposalComponent)
        return result

    @classmethod
    def set_game_state_callback(cls, ) -> None:
        """Wrapper for uwSetGameStateCallback."""
        result = cls.lib.uwSetGameStateCallback()
        return None

    @classmethod
    def game_state(cls, ) -> UwGameStateEnum:
        """Wrapper for uwGameState."""
        return cls.lib.uwGameState()

    @classmethod
    def set_update_callback(cls, ) -> None:
        """Wrapper for uwSetUpdateCallback."""
        result = cls.lib.uwSetUpdateCallback()
        return None

    @classmethod
    def set_shooting_callback(cls, ) -> None:
        """Wrapper for uwSetShootingCallback."""
        result = cls.lib.uwSetShootingCallback()
        return None

    @classmethod
    def set_explosions_callback(cls, ) -> None:
        """Wrapper for uwSetExplosionsCallback."""
        result = cls.lib.uwSetExplosionsCallback()
        return None

    @classmethod
    def set_force_eliminated_callback(cls, ) -> None:
        """Wrapper for uwSetForceEliminatedCallback."""
        result = cls.lib.uwSetForceEliminatedCallback()
        return None

    @classmethod
    def set_chat_callback(cls, ) -> None:
        """Wrapper for uwSetChatCallback."""
        result = cls.lib.uwSetChatCallback()
        return None

    @classmethod
    def set_task_completed_callback(cls, ) -> None:
        """Wrapper for uwSetTaskCompletedCallback."""
        result = cls.lib.uwSetTaskCompletedCallback()
        return None

    @classmethod
    def set_map_state_callback(cls, ) -> None:
        """Wrapper for uwSetMapStateCallback."""
        result = cls.lib.uwSetMapStateCallback()
        return None

    @classmethod
    def map_state(cls, ) -> UwMapStateEnum:
        """Wrapper for uwMapState."""
        return cls.lib.uwMapState()

    @classmethod
    def map_info(cls, UwMapInfo: Optional[ref]) -> bool:
        """Wrapper for uwMapInfo."""
        c_UwMapInfo = cls.ffi.new("struct ref *")
        result = cls.lib.uwMapInfo(c_UwMapInfo)
        return result

    @classmethod
    def map_starting_positions(cls, UwMapStartingPositionsArray: Optional[ref]) -> None:
        """Wrapper for uwMapStartingPositions."""
        c_UwMapStartingPositionsArray = cls.ffi.new("struct ref *")
        result = cls.lib.uwMapStartingPositions(c_UwMapStartingPositionsArray)
        return ref.from_c(cls.ffi, c_UwMapStartingPositionsArray)

    @classmethod
    def tiles_count(cls, ) -> int:
        """Wrapper for uwTilesCount."""
        return cls.lib.uwTilesCount()

    @classmethod
    def tile(cls, index: int, UwTile: Optional[ref]) -> None:
        """Wrapper for uwTile."""
        c_UwTile = cls.ffi.new("struct ref *")
        result = cls.lib.uwTile(index, c_UwTile)
        return ref.from_c(cls.ffi, c_UwTile)

    @classmethod
    def clusters_count(cls, ) -> int:
        """Wrapper for uwClustersCount."""
        return cls.lib.uwClustersCount()

    @classmethod
    def cluster(cls, index: int, UwCluster: Optional[ref]) -> None:
        """Wrapper for uwCluster."""
        c_UwCluster = cls.ffi.new("struct ref *")
        result = cls.lib.uwCluster(index, c_UwCluster)
        return ref.from_c(cls.ffi, c_UwCluster)

    @classmethod
    def area_range(cls, x: float, y: float, z: float, radius: float, UwIds: Optional[ref]) -> None:
        """Wrapper for uwAreaRange."""
        c_UwIds = cls.ffi.new("struct ref *")
        result = cls.lib.uwAreaRange(x, y, z, radius, c_UwIds)
        return ref.from_c(cls.ffi, c_UwIds)

    @classmethod
    def area_connected(cls, position: int, radius: float, UwIds: Optional[ref]) -> None:
        """Wrapper for uwAreaConnected."""
        c_UwIds = cls.ffi.new("struct ref *")
        result = cls.lib.uwAreaConnected(position, radius, c_UwIds)
        return ref.from_c(cls.ffi, c_UwIds)

    @classmethod
    def area_neighborhood(cls, position: int, radius: float, UwIds: Optional[ref]) -> None:
        """Wrapper for uwAreaNeighborhood."""
        c_UwIds = cls.ffi.new("struct ref *")
        result = cls.lib.uwAreaNeighborhood(position, radius, c_UwIds)
        return ref.from_c(cls.ffi, c_UwIds)

    @classmethod
    def area_extended(cls, position: int, radius: float, UwIds: Optional[ref]) -> None:
        """Wrapper for uwAreaExtended."""
        c_UwIds = cls.ffi.new("struct ref *")
        result = cls.lib.uwAreaExtended(position, radius, c_UwIds)
        return ref.from_c(cls.ffi, c_UwIds)

    @classmethod
    def test_visible(cls, x1: float, y1: float, z1: float, x2: float, y2: float, z2: float) -> bool:
        """Wrapper for uwTestVisible."""
        result = cls.lib.uwTestVisible(x1, y1, z1, x2, y2, z2)
        return result

    @classmethod
    def test_shooting(cls, shooterPosition: int, shooterProto: int, shootingRangeUpgrade: float, targetPosition: int, targetProto: int) -> bool:
        """Wrapper for uwTestShooting."""
        result = cls.lib.uwTestShooting(shooterPosition, shooterProto, shootingRangeUpgrade, targetPosition, targetProto)
        return result

    @classmethod
    def distance_line(cls, x1: float, y1: float, z1: float, x2: float, y2: float, z2: float) -> float:
        """Wrapper for uwDistanceLine."""
        result = cls.lib.uwDistanceLine(x1, y1, z1, x2, y2, z2)
        return result

    @classmethod
    def distance_estimate(cls, positionA: int, positionB: int) -> float:
        """Wrapper for uwDistanceEstimate."""
        result = cls.lib.uwDistanceEstimate(positionA, positionB)
        return result

    @classmethod
    def yaw(cls, startPosition: int, goalPosition: int) -> float:
        """Wrapper for uwYaw."""
        result = cls.lib.uwYaw(startPosition, goalPosition)
        return result

    @classmethod
    def start_clusters_distances(cls, UwClustersDistancesQuery: Optional[ref]) -> None:
        """Wrapper for uwStartClustersDistances."""
        c_UwClustersDistancesQuery = cls.ffi.new("struct ref *")
        result = cls.lib.uwStartClustersDistances(c_UwClustersDistancesQuery)
        return ref.from_c(cls.ffi, c_UwClustersDistancesQuery)

    @classmethod
    def retrieve_clusters_distances(cls, UwClustersDistancesResult: Optional[ref]) -> None:
        """Wrapper for uwRetrieveClustersDistances."""
        c_UwClustersDistancesResult = cls.ffi.new("struct ref *")
        result = cls.lib.uwRetrieveClustersDistances(c_UwClustersDistancesResult)
        return ref.from_c(cls.ffi, c_UwClustersDistancesResult)

    @classmethod
    def all_prototypes(cls, UwIds: Optional[ref]) -> None:
        """Wrapper for uwAllPrototypes."""
        c_UwIds = cls.ffi.new("struct ref *")
        result = cls.lib.uwAllPrototypes(c_UwIds)
        return ref.from_c(cls.ffi, c_UwIds)

    @classmethod
    def prototype_type(cls, prototypeId: int) -> UwPrototypeTypeEnum:
        """Wrapper for uwPrototypeType."""
        result = cls.lib.uwPrototypeType(prototypeId)
        return result

    @classmethod
    def prototype_json(cls, prototypeId: int) -> str:
        """Wrapper for uwPrototypeJson."""
        result = cls.lib.uwPrototypeJson(prototypeId)
        return _to_str(cls.ffi, result)

    @classmethod
    def definitions_json(cls, ) -> str:
        """Wrapper for uwDefinitionsJson."""
        return cls.lib.uwDefinitionsJson()

    @classmethod
    def hash_string(cls, str: str) -> int:
        """Wrapper for uwHashString."""
        result = cls.lib.uwHashString(_c_str(str))
        return result

    @classmethod
    def my_force_statistics(cls, UwMyForceStatistics: Optional[ref]) -> None:
        """Wrapper for uwMyForceStatistics."""
        c_UwMyForceStatistics = cls.ffi.new("struct ref *")
        result = cls.lib.uwMyForceStatistics(c_UwMyForceStatistics)
        return ref.from_c(cls.ffi, c_UwMyForceStatistics)

    @classmethod
    def unit_path_state(cls, unitId: int) -> UwPathStateEnum:
        """Wrapper for uwUnitPathState."""
        result = cls.lib.uwUnitPathState(unitId)
        return result

    @classmethod
    def unit_upgrades(cls, unit: int, UwUnitUpgrades: Optional[ref]) -> None:
        """Wrapper for uwUnitUpgrades."""
        c_UwUnitUpgrades = cls.ffi.new("struct ref *")
        result = cls.lib.uwUnitUpgrades(unit, c_UwUnitUpgrades)
        return ref.from_c(cls.ffi, c_UwUnitUpgrades)

    @classmethod
    def test_shooting_entities(cls, shooterId: int, targetId: int) -> bool:
        """Wrapper for uwTestShootingEntities."""
        result = cls.lib.uwTestShootingEntities(shooterId, targetId)
        return result

    @classmethod
    def test_construction_placement(cls, constructionProto: int, position: int, recipeProto: int) -> bool:
        """Wrapper for uwTestConstructionPlacement."""
        result = cls.lib.uwTestConstructionPlacement(constructionProto, position, recipeProto)
        return result

    @classmethod
    def find_construction_placement(cls, constructionProto: int, position: int, recipeProto: int) -> int:
        """Wrapper for uwFindConstructionPlacement."""
        result = cls.lib.uwFindConstructionPlacement(constructionProto, position, recipeProto)
        return result

    @classmethod
    def overview_flags(cls, position: int) -> UwOverviewFlags:
        """Wrapper for uwOverviewFlags."""
        result = cls.lib.uwOverviewFlags(position)
        return result

    @classmethod
    def overview_ids(cls, position: int, UwIds: Optional[ref]) -> None:
        """Wrapper for uwOverviewIds."""
        c_UwIds = cls.ffi.new("struct ref *")
        result = cls.lib.uwOverviewIds(position, c_UwIds)
        return ref.from_c(cls.ffi, c_UwIds)

    @classmethod
    def overview_extract(cls, UwOverviewExtract: Optional[ref]) -> None:
        """Wrapper for uwOverviewExtract."""
        c_UwOverviewExtract = cls.ffi.new("struct ref *")
        result = cls.lib.uwOverviewExtract(c_UwOverviewExtract)
        return ref.from_c(cls.ffi, c_UwOverviewExtract)

    @classmethod
    def start_unit_pathfinding(cls, UwUnitPathfindingQuery: Optional[ref]) -> None:
        """Wrapper for uwStartUnitPathfinding."""
        c_UwUnitPathfindingQuery = cls.ffi.new("struct ref *")
        result = cls.lib.uwStartUnitPathfinding(c_UwUnitPathfindingQuery)
        return ref.from_c(cls.ffi, c_UwUnitPathfindingQuery)

    @classmethod
    def retrieve_unit_pathfinding(cls, UwUnitPathfindingResult: Optional[ref]) -> None:
        """Wrapper for uwRetrieveUnitPathfinding."""
        c_UwUnitPathfindingResult = cls.ffi.new("struct ref *")
        result = cls.lib.uwRetrieveUnitPathfinding(c_UwUnitPathfindingResult)
        return ref.from_c(cls.ffi, c_UwUnitPathfindingResult)

    # Callback management
    _callbacks = {}

    @classmethod
    def add_exception_callback(cls, callback_func):
        """Add a callback for exception events."""
        key = "exception"
        if key not in cls._callbacks:
            cls._callbacks[key] = []
            cls._callbacks[key+"_func"] = cls._create_exception_callback()
        cls._callbacks[key].append(callback_func)
        return callback_func

    @classmethod
    def _create_exception_callback(cls):
        """Create a C callback for exception events."""
        @cls.ffi.callback("UwExceptionCallbackType")
        def _callback(message):
            for cb in cls._callbacks.get("exception", []):
                try:
                    cb(message)
                except Exception as e:
                    print(f"Error in exception callback: {e}")

        # Set the callback in the API
        cls.lib.uwSetExceptionCallback(_callback)
        return _callback

    @classmethod
    def add_log_callback(cls, callback_func):
        """Add a callback for log events."""
        key = "log"
        if key not in cls._callbacks:
            cls._callbacks[key] = []
            cls._callbacks[key+"_func"] = cls._create_log_callback()
        cls._callbacks[key].append(callback_func)
        return callback_func

    @classmethod
    def _create_log_callback(cls):
        """Create a C callback for log events."""
        @cls.ffi.callback("UwLogCallbackType")
        def _callback(data):
            for cb in cls._callbacks.get("log", []):
                try:
                    cb(ref.from_c(cls.ffi, data))
                except Exception as e:
                    print(f"Error in log callback: {e}")

        # Set the callback in the API
        cls.lib.uwSetLogCallback(_callback)
        return _callback

    @classmethod
    def add_connectionstate_callback(cls, callback_func):
        """Add a callback for connectionstate events."""
        key = "connectionstate"
        if key not in cls._callbacks:
            cls._callbacks[key] = []
            cls._callbacks[key+"_func"] = cls._create_connectionstate_callback()
        cls._callbacks[key].append(callback_func)
        return callback_func

    @classmethod
    def _create_connectionstate_callback(cls):
        """Create a C callback for connectionstate events."""
        @cls.ffi.callback("UwConnectionStateCallbackType")
        def _callback(state):
            for cb in cls._callbacks.get("connectionstate", []):
                try:
                    cb(UwConnectionStateEnum(state))
                except Exception as e:
                    print(f"Error in connectionstate callback: {e}")

        # Set the callback in the API
        cls.lib.uwSetConnectionStateCallback(_callback)
        return _callback

    @classmethod
    def add_gamestate_callback(cls, callback_func):
        """Add a callback for gamestate events."""
        key = "gamestate"
        if key not in cls._callbacks:
            cls._callbacks[key] = []
            cls._callbacks[key+"_func"] = cls._create_gamestate_callback()
        cls._callbacks[key].append(callback_func)
        return callback_func

    @classmethod
    def _create_gamestate_callback(cls):
        """Create a C callback for gamestate events."""
        @cls.ffi.callback("UwGameStateCallbackType")
        def _callback(state):
            for cb in cls._callbacks.get("gamestate", []):
                try:
                    cb(UwGameStateEnum(state))
                except Exception as e:
                    print(f"Error in gamestate callback: {e}")

        # Set the callback in the API
        cls.lib.uwSetGameStateCallback(_callback)
        return _callback

    @classmethod
    def add_update_callback(cls, callback_func):
        """Add a callback for update events."""
        key = "update"
        if key not in cls._callbacks:
            cls._callbacks[key] = []
            cls._callbacks[key+"_func"] = cls._create_update_callback()
        cls._callbacks[key].append(callback_func)
        return callback_func

    @classmethod
    def _create_update_callback(cls):
        """Create a C callback for update events."""
        @cls.ffi.callback("UwUpdateCallbackType")
        def _callback(tick, stepping):
            for cb in cls._callbacks.get("update", []):
                try:
                    cb(tick, stepping)
                except Exception as e:
                    print(f"Error in update callback: {e}")

        # Set the callback in the API
        cls.lib.uwSetUpdateCallback(_callback)
        return _callback

    @classmethod
    def add_shooting_callback(cls, callback_func):
        """Add a callback for shooting events."""
        key = "shooting"
        if key not in cls._callbacks:
            cls._callbacks[key] = []
            cls._callbacks[key+"_func"] = cls._create_shooting_callback()
        cls._callbacks[key].append(callback_func)
        return callback_func

    @classmethod
    def _create_shooting_callback(cls):
        """Create a C callback for shooting events."""
        @cls.ffi.callback("UwShootingCallbackType")
        def _callback(data):
            for cb in cls._callbacks.get("shooting", []):
                try:
                    cb(ref.from_c(cls.ffi, data))
                except Exception as e:
                    print(f"Error in shooting callback: {e}")

        # Set the callback in the API
        cls.lib.uwSetShootingCallback(_callback)
        return _callback

    @classmethod
    def add_explosions_callback(cls, callback_func):
        """Add a callback for explosions events."""
        key = "explosions"
        if key not in cls._callbacks:
            cls._callbacks[key] = []
            cls._callbacks[key+"_func"] = cls._create_explosions_callback()
        cls._callbacks[key].append(callback_func)
        return callback_func

    @classmethod
    def _create_explosions_callback(cls):
        """Create a C callback for explosions events."""
        @cls.ffi.callback("UwExplosionsCallbackType")
        def _callback(data):
            for cb in cls._callbacks.get("explosions", []):
                try:
                    cb(ref.from_c(cls.ffi, data))
                except Exception as e:
                    print(f"Error in explosions callback: {e}")

        # Set the callback in the API
        cls.lib.uwSetExplosionsCallback(_callback)
        return _callback

    @classmethod
    def add_forceeliminated_callback(cls, callback_func):
        """Add a callback for forceeliminated events."""
        key = "forceeliminated"
        if key not in cls._callbacks:
            cls._callbacks[key] = []
            cls._callbacks[key+"_func"] = cls._create_forceeliminated_callback()
        cls._callbacks[key].append(callback_func)
        return callback_func

    @classmethod
    def _create_forceeliminated_callback(cls):
        """Create a C callback for forceeliminated events."""
        @cls.ffi.callback("UwForceEliminatedCallbackType")
        def _callback(id):
            for cb in cls._callbacks.get("forceeliminated", []):
                try:
                    cb(id)
                except Exception as e:
                    print(f"Error in forceeliminated callback: {e}")

        # Set the callback in the API
        cls.lib.uwSetForceEliminatedCallback(_callback)
        return _callback

    @classmethod
    def add_chat_callback(cls, callback_func):
        """Add a callback for chat events."""
        key = "chat"
        if key not in cls._callbacks:
            cls._callbacks[key] = []
            cls._callbacks[key+"_func"] = cls._create_chat_callback()
        cls._callbacks[key].append(callback_func)
        return callback_func

    @classmethod
    def _create_chat_callback(cls):
        """Create a C callback for chat events."""
        @cls.ffi.callback("UwChatCallbackType")
        def _callback(msg, sender, flags):
            for cb in cls._callbacks.get("chat", []):
                try:
                    cb(msg, sender, UwChatTargetFlags(flags))
                except Exception as e:
                    print(f"Error in chat callback: {e}")

        # Set the callback in the API
        cls.lib.uwSetChatCallback(_callback)
        return _callback

    @classmethod
    def add_taskcompleted_callback(cls, callback_func):
        """Add a callback for taskcompleted events."""
        key = "taskcompleted"
        if key not in cls._callbacks:
            cls._callbacks[key] = []
            cls._callbacks[key+"_func"] = cls._create_taskcompleted_callback()
        cls._callbacks[key].append(callback_func)
        return callback_func

    @classmethod
    def _create_taskcompleted_callback(cls):
        """Create a C callback for taskcompleted events."""
        @cls.ffi.callback("UwTaskCompletedCallbackType")
        def _callback(taskUserData, type):
            for cb in cls._callbacks.get("taskcompleted", []):
                try:
                    cb(taskUserData, UwTaskTypeEnum(type))
                except Exception as e:
                    print(f"Error in taskcompleted callback: {e}")

        # Set the callback in the API
        cls.lib.uwSetTaskCompletedCallback(_callback)
        return _callback

    @classmethod
    def add_mapstate_callback(cls, callback_func):
        """Add a callback for mapstate events."""
        key = "mapstate"
        if key not in cls._callbacks:
            cls._callbacks[key] = []
            cls._callbacks[key+"_func"] = cls._create_mapstate_callback()
        cls._callbacks[key].append(callback_func)
        return callback_func

    @classmethod
    def _create_mapstate_callback(cls):
        """Create a C callback for mapstate events."""
        @cls.ffi.callback("UwMapStateCallbackType")
        def _callback(state):
            for cb in cls._callbacks.get("mapstate", []):
                try:
                    cb(UwMapStateEnum(state))
                except Exception as e:
                    print(f"Error in mapstate callback: {e}")

        # Set the callback in the API
        cls.lib.uwSetMapStateCallback(_callback)
        return _callback

# Initialize the API on module import
UwApi.initialize()

# Export UwSeverityEnum enum at module level for backwards compatibility
UwSeverityEnum = UwSeverityEnum
# Export UwConnectionStateEnum enum at module level for backwards compatibility
UwConnectionStateEnum = UwConnectionStateEnum
# Export UwOrderTypeEnum enum at module level for backwards compatibility
UwOrderTypeEnum = UwOrderTypeEnum
# Export UwOrderPriorityFlags enum at module level for backwards compatibility
UwOrderPriorityFlags = UwOrderPriorityFlags
# Export UwPriorityEnum enum at module level for backwards compatibility
UwPriorityEnum = UwPriorityEnum
# Export UwPingEnum enum at module level for backwards compatibility
UwPingEnum = UwPingEnum
# Export UwPathStateEnum enum at module level for backwards compatibility
UwPathStateEnum = UwPathStateEnum
# Export UwForeignPolicyEnum enum at module level for backwards compatibility
UwForeignPolicyEnum = UwForeignPolicyEnum
# Export UwChatTargetFlags enum at module level for backwards compatibility
UwChatTargetFlags = UwChatTargetFlags
# Export UwUnitStateFlags enum at module level for backwards compatibility
UwUnitStateFlags = UwUnitStateFlags
# Export UwPlayerStateFlags enum at module level for backwards compatibility
UwPlayerStateFlags = UwPlayerStateFlags
# Export UwPlayerConnectionClassEnum enum at module level for backwards compatibility
UwPlayerConnectionClassEnum = UwPlayerConnectionClassEnum
# Export UwForceStateFlags enum at module level for backwards compatibility
UwForceStateFlags = UwForceStateFlags
# Export UwGameStateEnum enum at module level for backwards compatibility
UwGameStateEnum = UwGameStateEnum
# Export UwTaskTypeEnum enum at module level for backwards compatibility
UwTaskTypeEnum = UwTaskTypeEnum
# Export UwMapStateEnum enum at module level for backwards compatibility
UwMapStateEnum = UwMapStateEnum
# Export UwPrototypeTypeEnum enum at module level for backwards compatibility
UwPrototypeTypeEnum = UwPrototypeTypeEnum
# Export UwOverviewFlags enum at module level for backwards compatibility
UwOverviewFlags = UwOverviewFlags
